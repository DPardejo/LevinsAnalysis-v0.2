levins_predictions_alternative <- function(OUT_LP = NA, MA_sa = NA, NTS = 1000,
save_file = "yes"){
	##
	## error message if the input is not a list object with the following eight elements:
	## [1] total number of matrices generated
	## [2] total number of stable matrices
	## [3] probability distribution
	## [4] community matrix
	## [5] (%) +
	## [6] (%) -
	## [7] (%) 0
	## [8] table of predictions
	##
	nomilista <- c("total number of matrices generated", "total number of stable matrices",
	"probability distribution", "community matrix", "(%) +", "(%) -", "(%) 0", "table of predictions")
	{
	if(length(names(OUT_LP)) == 0) l_ml <- 1
	else l_ml <- length(which(is.na(match(names(OUT_LP),nomilista))==TRUE))
	}
	##
	{
	if(is.list(OUT_LP) == TRUE){
		if(l_ml != 0){
			cat("\nerror: OUT_LP must be a list generated by the function \"levins_predictions\"")
			cat("\n\n")
			invisible(NULL)
		}
		##
		## sensitivity analysis for the additional interactions
		else{
			if(is.matrix(MA_sa) == FALSE){
				cat("\nerror: MA_sa must be a square matrix of the same size of the community matrix used with \"levins_predictions\"")
				cat("\n\n")
				invisible(NULL)
				}
			else{
				JJ <- OUT_LP[[4]]
				size_JJ <- ncol(JJ)
				{
				if(ncol(MA_sa) != size_JJ | nrow(MA_sa) != size_JJ){
					cat("\nerror: MA_sa must be a square matrix of the same size of the community matrix used with \"levins_predictions\"")
					cat("\n\n")
					invisible(NULL)
					}
				else{
					MA_sa1 <- MA_sa
					colnames(MA_sa1) <- rownames(MA_sa1) <- colnames(JJ)
					V_spa <- 0
					printa <- 0
					##
					## eliminate links in the alternative topology that are already in JJ
					for(i in 1:size_JJ){
						for(j in 1:size_JJ){
							if(JJ[i,j] != 0 & MA_sa1[i,j] != 0){
								{
								if(printa == 0){
									cat("\nwarning: some links indicated in MA_sa are already present in the reference community matrix\n")
									cat("the following links in MA_sa were therefore reset to 0:\n")
									cat(rownames(MA_sa1)[i], "\t", colnames(MA_sa1)[j], "\n", sep = "")
									MA_sa1[i,j] <- 0
									printa <- 1
								}
								else{
									cat(rownames(MA_sa1)[i], "\t", colnames(MA_sa1)[j], "\n", sep = "")
									MA_sa1[i,j] <- 0
									}
								}
							}
						}
					}
					##
					l_dz <- which(MA_sa1 != 0)
					##
					{
					if(length(l_dz) < 1){
						cat("\nerror: at least one link in MA_sa must be different from 0")
						cat("\n\n")
						invisible(NULL)
						}
					else{
						l_du <- which(MA_sa1 != 1 & MA_sa1 != (-1) & MA_sa1 != 0)
						if(length(l_du) != 0){
							cat("\nwarning: all non-zero values in MA_sa that differed from 1 or -1 were reset to\n")
							cat("either 1 or -1 depending on their sign (e.g. all negative values were reset to -1)")
							cat("\n\n")
							V_spa <- 1
							for(i in 1:length(l_du)){
								if(MA_sa1[l_du[i]] < 0)MA_sa1[l_du[i]] <- (-1)
								else MA_sa1[l_du[i]] <- 1
							}
						}
						##
						veto_l <- length(which(MA_sa1 != 0))
						veto <- c(1:veto_l)
						cou <- 1
						from <- rep(NA,veto_l)
						to <- rep(NA,veto_l)
						sig <- rep(NA,veto_l)
						edge <- cbind(from,to,sig)
						##
						for(i in 1:size_JJ){
							for(j in 1:size_JJ){
								if(MA_sa1[i,j] != 0){
								 edge[cou,1] <- i
								 edge[cou,2] <- j
								 edge[cou,3] <- MA_sa1[i,j]
								 cou <- cou + 1
								}
							}
						}
						##
						## length of all possible combinations
						l_cmb <- lapply(veto,function(x)combn(veto,x))
						v_apc <- unlist(lapply(veto,function(x)ncol(combn(veto,x))))
						l_apc <- sum(v_apc)
						##
						## list that contains all possible alternative topologies
						lista_apc <- as.list(rep(NA,l_apc))
						lista_apc_la <- as.list(rep(NA,l_apc))
						con <- 1
						for(i in 1:length(v_apc)){
							for(j in 1:v_apc[i]){
								lista_apc[[con]] <- matrix(rep(0,size_JJ^2), nrow = size_JJ)
								n_sel <- l_cmb[[i]][,j]
								for(k in 1:length(n_sel)){
									lista_apc[[con]][edge[n_sel[k],1],
									edge[n_sel[k],2]] <- edge[n_sel[k],3]
								}
								lista_apc_la[[con]] <- JJ + lista_apc[[con]]
								colnames(lista_apc[[con]]) <- rownames(lista_apc[[con]]) <- colnames(MA_sa1)
								con <- con + 1
							}
						}
						##
						##
						NTNn <- c(10, 100, 1000)
						NTNn_m <- length(which(is.na(match(NTS, NTNn))==FALSE))
						if(NTNn_m != 1){
							if(V_spa == 1)cat("warning: the number of runs for levins_predictions must be one of the following: 10, 100 or 1000\n")
							else cat("\nwarning: the number of runs for levins_predictions must be one of the following: 10, 100 or 1000\n")
							cat("NTS was reset to default option (i.e. 1000)\n\n")
							NTS <- 1000
							V_spa <- 1
						}
						##
						##
						SFn <- c("yes", "no")
						SFn_m <- length(which(is.na(match(save_file, SFn))==FALSE))
						if(SFn_m != 1){
							if(V_spa == 1)cat("warning: the user can decide whether to save (\"yes\") or not (\"no\") the predictions of all alternative scenarios\n")
							else cat("\nwarning: the user can decide whether to save (\"yes\") or not (\"no\") the predictions of all alternative scenarios\n")
							cat("save_file was reset to default option (i.e. \"yes\")\n\n")
							save_file <- "yes"
							V_spa <- 1
						}
						##
						##
						nomi_output <- c("reference_scenario", paste("scenario_",c(1:l_apc), sep = ""))
						##
						## executing loop analysis with all alternative topologies
						lista_lp_f <- as.list(rep(NA,(l_apc+1)))
						lista_lp_f[[1]] <- OUT_LP
						{
						if(V_spa == 1)cat("(1) levins predictions - reference scenario:\n")
						else cat("\n(1) levins predictions - reference scenario:\n")
						}
						cat(paste("\ntotal number of matrices generated: ", OUT_LP[[1]], sep = ""))
						cat("\n\n")
						cat(paste("total number of stable matrices: ", OUT_LP[[2]], sep = ""))
						cat("\n\n")
						cat(paste("the probability distribution used is:", OUT_LP[[3]], sep = " "))
						cat("\n\n\n")
						cat("community matrix")
						cat("\n\n")
						print(OUT_LP[[4]])
						cat("\n\n")
						cat("(%) + ")
						cat("\n\n")
						print(OUT_LP[[5]])
						cat("\n\n")
						cat("(%) - ")
						cat("\n\n")
						print(OUT_LP[[6]])
						cat("\n\n")
						cat("(%) 0 ")
						cat("\n\n")
						print(OUT_LP[[7]])
						cat("\n\n")
						cat("table of predictions")
						cat("\n\n")
						print(OUT_LP[[8]])
						cat("\n")
						##
						for(i in 1:l_apc){
							cat("\n##\n##\n\n")
							cat("\n(", (i+1), ") levins predictions, alternative topology - scenario ", i, ":\n", sep = "")
							{
							if(save_file == "yes")lista_lp_f[[(i+1)]] <- levins_predictions(lista_apc_la[[i]], NT = NTS,
							fname = nomi_output[(i+1)])
							else lista_lp_f[[(i+1)]] <- levins_predictions(lista_apc_la[[i]], NT = NTS)
							}
						}
						names(lista_lp_f) <- nomi_output
						##
						invisible(lista_lp_f)
						}
					}
					##
					}
				}
				##
				}
			}
		}
	else{
		cat("\nerror: OUT_LP must be a list generated by the function \"levins_predictions\"")
		cat("\n\n")
		invisible(NULL)
		}
	}
}
