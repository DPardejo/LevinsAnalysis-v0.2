#' Average strength of the Jacobian matrix interactions
#'
#' \code{cm_strength} returns the matrix of the average interaction
#'	strength based on simulation. Values are provided for all
#'	non-zero interactions of the community matrix \code{J}.
#'
#' @param J the square matrix describing the qualitative direct
#'	causal effects between the variables of the community matrix.
#'	See \code{Note} for more details.
#' @param RM the parameter that allows selecting the distribution
#'	from which the coefficients are randomly sampled and assigned
#'	to interactions during simulation. Possible values: \code{"uniform"}
#'	(default), \code{"normal"}, or \code{"pareto"}.
#'	See \code{Details} for more information on use.
#' @param INT_MIN the matrix used to define the lower value that should
#'	be considered by the function when randomly generating the strength
#'	of specific interactions during simulation. The default option is
#'	\code{NA}, which indicates that the minimum strength attained by
#'	each non-zero interaction is \code{1e-6}.
#'	@param INT_MAX the matrix used to define the upper value that should
#'	be considered by the function when randomly generating the strength
#'	of specific interactions during simulation. The default option is
#'	\code{NA}, which indicates that the maximum strength attained by
#'	each non-zero interaction is \code{1}.
#' @param NT the number number of random matrices that are generated by
#'	the function. The default value is 1000.
#' @param fname the name of the file where the results are stored.
#'	No file is exported when NA (default) is selected.
#'
#' @export
#'
#' @importFrom MASS ginv
#' @importFrom msm rtnorm
#' @importFrom stats runif
#'
#' @details \itemize{ \item Through the argument \code{RM} the user can
#'	define the type of distribution to be used to extract the values of
#'	intensity for the coefficient of interaction between variable
#'	\code{i} and variable \code{j} of the community matrix \code{J}.
#'	Options are: \itemize{\item \code{"uniform"} coefficients are
#'	extracted from uniform probability distribution (default);
#'	\item \code{"normal"} coefficients are extracted from (truncated)
#'	normal probability distribution with mean = 0.5 and sd = 0.2;
#'	\item \code{"pareto"} coefficientsare extracted from Pareto
#'	(i.e. power-law) probability distribution with minimum value;
#'	minimum value (location) = 1 and exponent (shape) = 8.8; \item
#'	see \code{Note} for more information and \code{Examples} for
#'	practical use}
#'	\item The arguments \code{INT_MIN} and \code{INT_MAX} have
#'	\code{NA} as default option. In such case all simulations are
#'	performed by randomly sampling values in the interval [1e-6, 1],
#'	according to the distribution type indicated with the argument
#'	\code{RM}. Alternative minimum and maximum thresholds can be
#'	changed by the user but must always lie in the interval [1e-6, 1].
#'	\code{INT_MIN} and \code{INT_MAX} must be explicitly
#'	provided only if the minimum or maximum values of specific
#'	interactions are different from default. User-defined thresholds
#'	must be in square matrices that have the sime size as the
#'	community matrix \cite{J}. If a value is modified
#'	for a specific interaction in \code{INT_MIN} it does not imply
#'	that the corresponding entry must be changed in \code{INT_MAX}
#'	(and viceversa). All zero entries in the matrices used as
#'	input for the arguments \code{INT_MIN} and \code{INT_MAX}
#'	indicate that default thresholds should be adopted
#'	during simulation (i.e. minimum = 1e-6, maximum = 1). If the
#'	user intends to define an exact interaction strength for
#'	a specific interaction the same value should be used in the
#'	corresponding entry of both matrices \code{INT_MIN} and
#'	\code{INT_MIN}. See \cite{Note} for more details and
#'	\cite{Examples} for practical use. \item The interaction
#'	strength of the Jacobian matrix interactions are quantified
#'	over \cite{NT} * \cite{n} runs (where \cite{n} is the size
#'	of the Jacobian matrix \cite{J}). In each run a matrix
#'	with randomly assigned interaction strengths is created
#'	and it stability verified. Stable matrices only are
#'	considered to calculate the average strength of interactions.
#'	The argument \cite{NT} has 1000 as default value, but the user
#'	can modify the number of times simulations are carried out
#'	per each variable (i.e. \code{number of runs = size of J * NT}).
#'	See \cite{Examples} for practical use. \item \code{fname} should
#'  be provided by the user to export the results in a text file
#'  with the suffix \code{"_cm_strength.txt"}. Default option is that
#'	no text files are saved. See \code{Examples} for pratical use.}
#'
#' @note \itemize{ \item The matrix \code{J} should be formatted
#'	as follows: \itemize{ \item qualitative direct causal links
#'	must be from \code{i} (rows) variables to \code{j} (columns)
#'	variables; \item direct causal links takes the following
#'	coefficients: 1 for positive interactions, -1 for negative
#'	interactions, and 0 for no interaction; \item the positive
#'	effect of the variable \code{i} on the variable \code{j} is
#'	represented by an arrow-headed link from \code{i} to \code{j};
#'	\item the negative effect of the variable \code{i} on the
#'	variable \code{j} is represented by a circle-headed link
#'	from \code{i} to \code{j}.} \item The \code{RM} probability
#'	distribution from which strength values are randomly sampled
#' can be \code{uniform}, \code{normal} (with mean = 0.5 and
#'	sd = 0.2; such distribution is trunctated, meaning that values
#'	outside the renge [1e-6, 1] are discarded), or \code{pareto}
#'	(i.e. power-law distribution) with minimum value (i.e. location)
#'	 = 1 and exponent (i.e. shape) = 8.8. \item The \code{INT_MIN}
#'	and \code{INT_MAX} matrices: \itemize{ \item should be written
#'	with non-zero entries when minimum and/or maximum thresholds
#'	do not correspond to default values (i.e. 0 and 1,
#'	respectively); \item the value of all interaction strengths
#'	must lie in the interval [1e-6, 1] and user-defined thresholds
#'	only apply to matrices generated with \cite{RM = "uniform"}
#'	(i.e. \code{INT_MIN} and \code{INT_MAX} do not work with
#'	\cite{"normal"} and \cite{"pareto"} distributions; in such case
#'	the function runs the analysis by arbitrarily setting
#'	\cite{RM = "uniform"})}}
#'
#' @return Total number of matrices generated (i.e. the total number
#'	of runs performed), the total number of stable matrices (i.e.
#'	those effectively used for calculating the average interaction
#'	strengths), the probability distribution used (i.e. \code{"uniform"},
#'	\code{"normal"} or \code{"pareto"}), and the matrix with average
#'	interaction strength for each non-zero interaction in the community
#'	matrix \code{J}. If \code{fname} is a user-defined name of type
#'	\cite{character} the results are saved in the file named
#'	\code{"fname_cm_strength.txt"}. The output also consists of an
#'	\code{invisible} list that can be can be assigned to an object.
#'
#' @keywords arith, array, datagen, distribution, math, print
#'
#' @concept interaction, levins, loop, network, strength
#'
#' @seealso \code{\link{cm_paths}}, \code{\link{cm_stability}},
#'   \code{\link{levins_prediction}}, \code{\link{levins_concurrent}},
#'   \code{\link{J}}
#'
#' @examples
#'	## To compute the average interaction strengths of M using uniform
#'	## distribution without saving the results in the text file
#'	cm_strength(M)
#'
#'	## To assign the invisible list with all results (in presence of
#'	## community matrix M and all default options
#'	M_strength <- cm_strength(M)
#'	M_strength
#'
#'	## To compute average interaction strengths for the community
#'	## matrix M using the uniform distribution and saving the
#'	## results in the file "M_cm_strength.txt"
#'	cm_strength(M, fname = "M")
#'
#'	## To compute the average interaction strength of the community
#'	## matrix M by randomly sampling the strength of each interaction
#'	## from the truncated normal distribution (mean = 0.5, sd = 0.2)
#'	cm_strength(M, RM = "normal")
#'
#'	## To compute the average interaction strength of the community
#'	## matrix M by randomly sampling the strength of each interaction
#'	## from the Pareto distribution
#'	cm_strength(M, RM = "pareto")
#'
#'	## The average interaction strengths in case of user-defined limits
#'	##
#'	## (1) If the user knows that in the community matrix M the
#'	## interaction from node A to node B can attain the minimum value
#'	## of 0.5, then the matrix M_min has to be explicitly provided
#'	## for the argument INT_MIN
#'	M_min <- matrix(c(0, 0.5, 0, 0, 0,
#'	0, 0, 0, 0, 0,
#'	0, 0, 0, 0, 0,
#'	0, 0, 0, 0, 0,
#'	0, 0, 0, 0, 0), nrow = 5, byrow = TRUE)
#'	colnames(M_min) <- colnames(M)
#'	rownames(M_min) <- rownames(M)
#'	cm_strength(J = M, INT_MIN = M_min)
#'	##
#'	## (2) In the same way, if the user knows that in the community
#'	## matrix M the interaction strength from node C to node D can
#'	## attain the maximum (absolute) value of 0.8, then the matrix
#'	## M_max has to be explicitly provided for the argument INT_MAX
#'	ro <- nrow(M)
#'	el <- nrow(M)^2
#'	M_max <- matrix(rep(0, el), nrow = ro)
#'	colnames(M_max) <- colnames(M)
#'	rownames(M_max) <- rownames(M)
#'	M_max["C","D"] <- 0.8
#'	cm_strength(J = M, INT_MAX = M_max)
#'
#'	## When average interaction strengths are computed knowing the
#'	## exact (absolute) value of one interaction in the community
#'	## matrix M (i.e. the effect of D on E is 0.4), then the
#'	## following code must be used:
#'	ro <- nrow(M)
#'	el <- nrow(M)^2
#'	matrix_min <- matrix(rep(0, el), nrow = ro)
#'	colnames(matrix_min) <- colnames(M)
#'	rownames(matrix_min) <- rownames(M)
#'	matrix_min["D", "E"]<- 0.4
#'	matrix_max <- matrix_min
#'	cm_strength(M, INT_MIN = matrix_min, INT_MAX = matrix_max)
#'
#'	## To compute the average interaction strengths associated to
#'	## the community matrix M and using Pareto distribution with
#'	## user-defined number of runs (i.e. 100 for each variable, for
#'	## a total of 500 runs):
#'	cm_strength(M, RM = "pareto", NT = 100)
#'
#' @author Daniel Pereira \email{dsldlf@@unife.it}, Marta Rocchi, Stefania
#'   Favilla, Antonio Bodini, Marco Scotti \email{marcoscot@@gmail.com}
#'
#' @references \itemize{ \item Our Manual
#'	\item Martone, R.G., Bodini, A.,
#'	Micheli, F., 2017. Identifying potential consequences of natural
#'	perturbations and management decisions on a coastal fishery
#'	social-ecological system using qualitative loop analysis.
#'	Ecology and Society 22, 34.
#'	\url{https://doi.org/10.5751/ES-08825-220134}
#'	\item Bodini, A., Rocchi, M.
#'	Scotti, M., 2018. Insights into the ecology of the Black Sea through
#'	the qualitative loop analysis of the community structure.
#'	Limnology and Oceanography 63, 968-984.
#'	\url{https://doi.org/10.1002/lno.10713}}
#'
#'
la_strength <- function(J, RM = "uniform", INT_MIN = NA, INT_MAX = NA, NT = 1000, fname = NA){
	##
	## error message if the input is not a square numeric matrix
	if(is.matrix(J) == FALSE | is.numeric(J) == FALSE){
		cat("\nerror: the input must be a square numeric matrix")
		cat("\n\n")
		invisible(NULL)
	}
	else{
		## number of rows and columns
		n_rows <- nrow(J)
		n_cols <- ncol(J)
		##
		## square matrix check
		{
		if(n_rows == n_cols){
			##
			## names of the nodes
			names_n <- colnames(J)
			##
			## transpose of J
			t_J <- t(J)
			##
			## total number of nodes
			n_nodes <- sqrt(length(J))
			##
			## total number of possible links (complete matrix with self-loops)
			n_nodes2 <- n_nodes^2
			##
			## total number of runs = number of nodes * NT
			{
			if(is.numeric(NT) == FALSE){
				NT <- 1000
				cat("\nwarning: NT must be strictly positive and integer and was reset to NT = 1000")
				cat("\n")
				}
			else{
				if(is.list(NT) == TRUE | is.matrix(NT) == TRUE | length(NT) > 1){
				NT <- 1000
				cat("\nwarning: NT must be strictly positive and integer and was reset to NT = 1000")
				cat("\n")
				}
				else if(check_positive_integers(NT) == FALSE){
					NT <- 1000
					cat("\nwarning: NT must be strictly positive and integer and was reset to NT = 1000")
					cat("\n")
					}
				}
			}
			ntent <- (length(t_J[1,]) * NT)
			##
			## empty vector to store the determinant of all random matrices
			det_list <- rep(NA,ntent)
			##
			## empty list to store all random matrices that are stable
			## (in case of unstable matrices the corresponding element of the list is 0)
			weighted_list <- as.list(rep(0,ntent))
			##
			## empty vector to record which random matrices are stable
			stable_list <- rep(0,ntent)
			##
			## check of the type of probability distribution
			all_distr <- c("uniform","normal","pareto")
			{
			if(length(RM) != 1){
				RM <- "uniform"
				cat("\nwarning: RM must be one of the three following probability distributions: \"uniform\", \"normal\" or \"pareto\"\n")
				cat("RM was reset to default option (i.e. RM = \"uniform\")")
				cat("\n")
				}
			else{
				if(length(which(all_distr == RM)) != 1){
					RM <- "uniform"
					cat("\nwarning: RM must be one of the three following probability distributions: \"uniform\", \"normal\" or \"pareto\"\n")
					cat("RM was reset to default option (i.e. RM = \"uniform\")")
					cat("\n")
					}
				}
			}
			##
			## check of the format of the matrices that define maximum and minimum thresholds for random sampling
			conteggio <- 0
			{
			if(is.matrix(INT_MIN) == TRUE & is.numeric(INT_MIN) == TRUE){
				if(nrow(INT_MIN) == n_nodes & ncol(INT_MIN) == n_nodes){
					if(max(INT_MIN) <= 1 & min(INT_MIN) >= 0){
						t_user_d_int_min <- t(INT_MIN)
						if(RM == "normal" | RM == "pareto"){
							conteggio <- 1
							cat("\nwarning: user-defined thresholds for random sampling only apply to \"uniform\" distribution\n")
							cat("RM was reset to default option (i.e. RM = \"uniform\")")
							cat("\n")
							RM <- "uniform"
							}
						}
					else{
						for(i in 1:n_nodes){
							for(j in 1:n_nodes){
								if(INT_MIN[i,j] > 1 | INT_MIN[i,j] < 0)INT_MIN[i,j] <- 0
								}
							}
							t_user_d_int_min <- t(INT_MIN)
							if(RM == "normal" | RM == "pareto"){
								conteggio <- 1
								cat("\nwarning: user-defined thresholds for random sampling only apply to \"uniform\" distribution\n")
								cat("RM was reset to default option (i.e. RM = \"uniform\")")
								cat("\n")
								RM <- "uniform"
							}
							cat("\nwarning: all values of INT_MIN must be in the interval (0, 1]\n")
							cat("values outside such interval were reset to default option (i.e. 1e-6)")
							cat("\n")
						}
					}
				else{
					t_user_d_int_min <- matrix(rep(0,n_nodes2), nrow = n_nodes)
					if(RM == "normal" | RM == "pareto"){
						conteggio <- 1
						cat("\nwarning: user-defined thresholds for random sampling only apply to \"uniform\" distribution\n")
						cat("RM was reset to default option (i.e. RM = \"uniform\")")
						cat("\n")
						RM <- "uniform"
					}
					cat("\nwarning: INT_MIN must be a square matrix with same size as J\n")
					cat("INT_MIN was reset to default size with all values = 1e-6")
					cat("\n")
					}
				}
			else{
				if(is.na(INT_MIN[1]) == TRUE){
					t_user_d_int_min <- matrix(rep(0,n_nodes2), nrow = n_nodes)
					}
				else{
					t_user_d_int_min <- matrix(rep(0,n_nodes2), nrow = n_nodes)
					if(RM == "normal" | RM == "pareto"){
						conteggio <- 1
						cat("\nwarning: user-defined thresholds for random sampling only apply to \"uniform\" distribution\n")
						cat("RM was reset to default option (i.e. RM = \"uniform\")")
						cat("\n")
						RM <- "uniform"
					}
					cat("\nwarning: INT_MIN must be a square matrix with same size as J\n")
					cat("INT_MIN was reset to default size with all values = 1e-6")
					cat("\n")
					}
				}
			}
			##
			{
			if(is.matrix(INT_MAX) == TRUE & is.numeric(INT_MAX) == TRUE){
				if(nrow(INT_MAX) == n_nodes & ncol(INT_MAX) == n_nodes){
					if(max(INT_MAX) <= 1 & min(INT_MAX) >= 0){
						t_user_d_int_max <- t(INT_MAX)
						if(RM == "normal" | RM == "pareto"){
							if(conteggio == 0){
								cat("\nwarning: user-defined thresholds for random sampling only apply to \"uniform\" distribution\n")
								cat("RM was reset to default option (i.e. RM = \"uniform\")")
								cat("\n")
								RM <- "uniform"
								}
							}
						}
					else{
						for(i in 1:n_nodes){
							for(j in 1:n_nodes){
								if(INT_MAX[i,j] > 1 | INT_MAX[i,j] < 0)INT_MAX[i,j] <- 1
								}
							}
							if(RM == "normal" | RM == "pareto"){
								if(conteggio == 0){
									cat("\nwarning: user-defined thresholds for random sampling only apply to \"uniform\" distribution\n")
									cat("RM was reset to default option (i.e. RM = \"uniform\")")
									cat("\n")
									RM <- "uniform"
								}
							}
							t_user_d_int_max <- t(INT_MAX)
							cat("\nwarning: all values of INT_MAX must be in the interval (0, 1]\n")
							cat("values outside such interval were reset to default option (i.e. 1)")
							cat("\n")
						}
					}
				else{
					t_user_d_int_max <- matrix(rep(0,n_nodes2), nrow = n_nodes)
					if(RM == "normal" | RM == "pareto"){
						if(conteggio == 0){
							cat("\nwarning: user-defined thresholds for random sampling only apply to \"uniform\" distribution\n")
							cat("RM was reset to default option (i.e. RM = \"uniform\")")
							cat("\n")
							RM <- "uniform"
						}
					}
					cat("\nwarning: INT_MAX must be a square matrix with same size as J\n")
					cat("INT_MAX was reset to default size with all values = 1")
					cat("\n")
					}
				}
			else{
				if(is.na(INT_MAX[1]) == TRUE){
					t_user_d_int_max <- matrix(rep(0,n_nodes2), nrow = n_nodes)
					}
				else{
					t_user_d_int_max <- matrix(rep(0,n_nodes2), nrow = n_nodes)
					if(RM == "normal" | RM == "pareto"){
						if(conteggio == 0){
							cat("\nwarning: user-defined thresholds for random sampling only apply to \"uniform\" distribution\n")
							cat("RM was reset to default option (i.e. RM = \"uniform\")")
							cat("\n")
							RM <- "uniform"
						}
					}
					cat("\nwarning: INT_MAX must be a square matrix with same size as J\n")
					cat("INT_MAX was reset to default size with all values = 1")
					cat("\n")
					}
				}
			}
			##
			matrice_somma_user <- t_user_d_int_min + t_user_d_int_max
			indicatore <- sum(matrice_somma_user)
			t_user_d_int_min_f <- t_user_d_int_min
			t_user_d_int_max_f <- t_user_d_int_max
			##
			for(i in 1:n_nodes){
				for(j in 1:n_nodes){
					if(t_user_d_int_min[i,j] == 0)t_user_d_int_min_f[i,j] <- 1e-6
					##
					if(t_user_d_int_max[i,j] == 0)t_user_d_int_max_f[i,j] <- 1
				}
			}
			##
			## check there are no entries in the matrix of minimum thresholds that exceed those in the matrix of maximum thresholds
			coun <- 0
			for(i in 1:n_nodes){
				for(j in 1:n_nodes){
					if(t_user_d_int_min_f[i,j] > t_user_d_int_max_f[i,j]){
						t_user_d_int_min_f[i,j] <- 1e-6
						t_user_d_int_max_f[i,j] <- 1
						{
						if(coun == 0){
							cat("\nwarning: each entry in INT_MIN must not exceed the corresponding one in INT_MAX\n")
							cat("the following entries were reset to default values (INT_MIN = 1e-6, INT_MAX = 1):\n")
							cat(rownames(J)[j], colnames(J)[i], "\n", sep = " ")
							coun <- 1
							}
						else{
							cat(rownames(J)[j], colnames(J)[i], "\n", sep = " ")
							}
						}
					}
				}
			}
			##
			##
			k <- 1
			##
			##
			for(k in 1:ntent){
				##
				casuale <- matrix(rep(0,n_nodes2), nrow = n_nodes)
				##
				## uniform distribution
				if(RM == "uniform"){
					if(indicatore == 0){
						for(i in 1:n_nodes){
							for(j in 1:n_nodes){
								casuale[i,j] <- runif(n = 1, min = 1e-6, max = 1)
							}
						}
					}
					##
					else{
						for(i in 1:n_nodes){
							for(j in 1:n_nodes){
								casuale[i,j] <- runif(n = 1, min = t_user_d_int_min_f[i,j],
								max = t_user_d_int_max_f[i,j])
							}
						}
					}
				}
				##
				## normal distribution
				if(RM == "normal"){
					for(i in 1:n_nodes){
						for(j in 1:n_nodes){
							casuale[i,j] <- rtnorm(1, mean = 0.5, sd = 0.2,
							lower = 1e-6, upper = 1)
						}
					}
				}
				##
				## Pareto distribution
				if(RM == "pareto"){
					qpareto <- function(u, shape = 1, location = 1)
					location/(1 - u)^(1/shape);
					rpareto <- function(n, shape = 1, location = 1)
					qpareto(runif(n), shape, location);
					for(i in 1:n_nodes){
						for(j in 1:n_nodes){
							repeat{
								vu <- rpareto(1, shape = 8.8) - 1
								if(vu >= 1e-6 & vu <= 1){
									break
								}
							}
							casuale[i,j] <- vu
						}
					}
				}
				##
				num <- 0
				ww <- matrix(rep(0,n_nodes2), nrow = n_nodes)
				for(i in 1:n_nodes){
					for(j in 1:n_nodes){
						ww[i,j] <- t_J[i,j] * casuale[i,j]
					}
				}
				##
				det_ww <- round(det(ww), digits = 6)
				##
				## the criterion for stability is that the real part
				## of every eigenvalue of J must be negative
				eig_vre <- round(Re(eigen(ww)$values), digits = 6)
				##
				## the imaginary part of eigenvalues of J is not considered
				## eig_vim <- round(Im(eigen(ww)$values), digits = 6)
				##
				num <- length(which(eig_vre < 0))
				##
				if((num - n_nodes) == 0){
					##
					## if all the eigenvalues of [ww] have real part negative then the system is stable
					## here we store the determinant of stable matrices
					det_list[k] <- det(ww)
					##
					## the stable matrices are stored
					## in case of unstable matrices, the element of the list has value = 0
					weighted_list[[k]] <- ww
					##
					## vector with elements = 1 in case of stable matrices
					stable_list[k] <- 1
				}
			}
			##
			## calculation of the average strength matrix from all accepted random matrices
			## (i.e. all stable matrices for which any eigenvalue that has a negative real part)
			n_stable <- sum(stable_list)
			cat(paste("\ntotal number of matrices generated: ", ntent, sep = ""))
			cat("\n\n")
			cat(paste("total number of stable matrices: ", n_stable, sep = ""))
			cat("\n\n")
			cat(paste("the probability distribution used is:", RM, sep = " "))
			cat("\n\n")
			##
			average_casuale <- Reduce("+", weighted_list)/n_stable
			colnames(average_casuale) <- names_n
			rownames(average_casuale) <- names_n
			average_strength <- t(average_casuale)
			cat("average strength matrix")
			cat("\n\n")
			print(average_strength)
			cat("\n")
			##
			## list of results
			list_results <- as.list(rep(NA, 4))
			names(list_results) <- c("total number of matrices generated",
			"total number of stable matrices",
			"probability distribution",
			"average strength matrix")
			list_results[[1]] <- ntent
			list_results[[2]] <- n_stable
			list_results[[3]] <- RM
			list_results[[4]] <- average_strength
			##
			## the list of results is saved in a text file
			{
			if(is.character(fname) == TRUE){
				file_name_txt <- paste(fname, "_la_strength.txt", sep = "")
				sink(file_name_txt)
				print(list_results)
				sink()
				cat(paste("results are in the file \"", file_name_txt, "\"", sep = ""))
				cat("\n\n")
				}
			##
			else{
				if(length(fname) != 1){
					cat("error: the filename must be of type \"character\"")
					cat("\n\n")
					}
				else if(is.na(fname) == FALSE){
					cat("error: the filename must be of type \"character\"")
					cat("\n\n")
				}
			}
			##
			}
			##
			## invisible object for the list of results
			invisible(list_results)
		}
		else{
			cat("\nerror: the input must be a square numeric matrix")
			cat("\n\n")
			invisible(NULL)
			}
		}
	}
}
