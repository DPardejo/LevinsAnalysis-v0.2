predictions_heatmap <- function(OUT_LP = NA, cell_n = "yes", dist_m = "manhattan", hclust_m = "ward.D2",
save_file = "pdf", fname = "community"){
	##
	## error message if the input is not a list object with the following eight elements:
	## [1] total number of matrices generated
	## [2] total number of stable matrices
	## [3] probability distribution
	## [4] community matrix
	## [5] (%) +
	## [6] (%) -
	## [7] (%) 0
	## [8] table of predictions
	##
	nomilista <- c("total number of matrices generated", "total number of stable matrices",
	"probability distribution", "community matrix", "(%) +", "(%) -", "(%) 0", "table of predictions")
	{
	if(length(names(OUT_LP)) == 0) l_ml <- 1
	else l_ml <- length(which(is.na(match(names(OUT_LP),nomilista))==TRUE))
	}
	##
	{
	if(is.list(OUT_LP) == TRUE){
		if(l_ml != 0){
			cat("\nerror: OUT_LP must be a list generated by the function \"levins_predictions\"")
			cat("\n\n")
			invisible(NULL)
		}
		##
		## heatmap visualization
		else{
			##
			V_spa <- 0
			##
			## decision whether to include signs in heatmap cells
			names_celln <- c("yes", "no")
			names_celln_m <- length(which(is.na(match(cell_n, names_celln))==FALSE))
			if(names_celln_m != 1){
				cat("\nwarning: the user can decide whether to include (\"yes\") or not (\"no\") the cell signs in the heatmap:\n")
				cat("cell_n was reset to default option (i.e. \"yes\")\n\n")
				cell_n <- "yes"
				V_spa <- 1
			}
			##
			## type of distance measure
			names_distancem <- c("euclidean", "maximum", "manhattan", "minkowski")
			names_distancem_m <- length(which(is.na(match(dist_m, names_distancem))==FALSE))
			if(names_distancem_m != 1){
				if(V_spa == 1)cat("warning: the distance measure must be one of the following:\n")
				else cat("\nwarning: the distance measure must be one of the following:\n")
				cat("\"euclidean\", \"maximum\", \"manhattan\" or \"minkowski\"\n")
				cat("dist_m was reset to default option (i.e. \"manhattan\")\n\n")
				dist_m <- "manhattan"
				V_spa <- 1
			}
			##
			## method for hierarchical cluster analysis
			names_clusterm <- c("ward.D", "ward.D2", "single", "complete", "average", "mcquitty")
			names_clusterm_m <- length(which(is.na(match(hclust_m, names_clusterm))==FALSE))
			if(names_clusterm_m != 1){
				if(V_spa == 1)cat("warning: hierarchical cluster analysis must use one of the following methods:\n")
				else cat("\nwarning: hierarchical cluster analysis must use one of the following methods:\n")
				cat("\"ward.D\", \"ward.D2\", \"single\", \"complete\", \"average\" or \"mcquitty\"\n")
				cat("hclust_m was reset to default option (i.e. \"ward.D2\")\n\n")
				hclust_m <- "ward.D2"
				V_spa <- 1
			}
			##
			## extension for saving the heatmap
			all_ext <- c("pdf","svg")
			{
			if(length(save_file) > 1 | is.vector(save_file) == FALSE){
				{
				if(V_spa == 1)cat("warning: the format of the image file must be one of the following: \"pdf\" or \"svg\"")
				else cat("\nwarning: the format of the image file must be one of the following: \"pdf\" or \"svg\"")
				}
				cat("\n")
				cat("the format was reset to default (i.e. \"pdf\")")
				cat("\n\n")
				save_file <- "pdf"
				V_spa <- 1
				}
			else{
				s_ext <- which(all_ext == save_file)
				if(length(s_ext) != 1){
					{
					if(V_spa == 1)cat("warning: the format of the image file must be one of the following: \"pdf\" or \"svg\"")
					else cat("\nwarning: the format of the image file must be one of the following: \"pdf\" or \"svg\"")
					}
					cat("\n")
					cat("the format was reset to default (i.e. \"pdf\")")
					cat("\n\n")
					save_file <- "pdf"
					}
				}
			}
			##
			## filename must be a unique element of type character
			{
			if(is.character(fname) == FALSE){
				if(V_spa == 1)cat("warning: the name of the image file must be of type \"character\"\n")
				else cat("\nwarning: the name of the image file must be of type \"character\"\n")
				cat("the name was reset to default option (i.e. \"community\")\n\n")
				fname <- "community"
				V_spa <- 1
				}
			else if(is.character(fname) == TRUE & length(fname) > 1){
				if(V_spa == 1)cat("warning: the name of the image file must be a single element of type \"character\"\n")
				else cat("\nwarning: the name of the image file must be a single element of type \"character\"\n")
				cat("the name was reset to default option (i.e. \"community\")\n\n")
				fname <- "community"
				V_spa <- 1
				}
			}
			##
			##
			redblue <- c("red", "blue")
			##
			AC <- OUT_LP$`(%) +` - OUT_LP$`(%) -`
			##
			## produce an svg file in the working directory
			{
			if(save_file == "svg"){
				file_name1 <- paste(fname, "_predictions_heatmap.", save_file, sep = "")
				##
				svg(filename = file_name1)
				##
				{
				if(cell_n == "yes"){
					heatmap.2(AC, dendrogram = "both", cellnote = OUT_LP$`table of predictions`,
					notecol = "black", col = redblue(41), scale = "none", key = TRUE, keysize = 1.1,
					density.info = "none", trace = "none", cexRow = 1.1, cexCol = 1.1,
					breaks = seq(-100, 100, length.out = 42), srtCol = 0, lhei = c(1.2,5),
					key.xlab = "response strength", key.title = "",
					distfun = function(x)dist(x, method = dist_m), hclustfun = function(x)
					hclust(x, method = hclust_m))
					}
				else{
					heatmap.2(AC, dendrogram = "both",
					notecol = "black", col = redblue(41), scale = "none", key = TRUE, keysize = 1.1,
					density.info = "none", trace = "none", cexRow = 1.1, cexCol = 1.1,
					breaks = seq(-100, 100, length.out = 42), srtCol = 0, lhei = c(1.2,5),
					key.xlab = "response strength", key.title = "",
					distfun = function(x)dist(x, method = dist_m), hclustfun = function(x)
					hclust(x, method = hclust_m))
					}
				}
				##
				dev.off()
				}
			else{
				##
				## produce a pdf file in the working directory
				if(save_file == "pdf"){
					file_name2 <- paste(fname, "_predictions_heatmap.", save_file, sep = "")
					##
					pdf(file = file_name2)
					##
					{
					if(cell_n == "yes"){
						heatmap.2(AC, dendrogram = "both", cellnote = OUT_LP$`table of predictions`,
						notecol = "black", col = redblue(41), scale = "none", key = TRUE, keysize = 1.1,
						density.info = "none", trace = "none", cexRow = 1.1, cexCol = 1.1,
						breaks = seq(-100, 100, length.out = 42), srtCol = 0, lhei = c(1.2,5),
						key.xlab = "response strength", key.title = "",
						distfun = function(x)dist(x, method = dist_m), hclustfun = function(x)
						hclust(x, method = hclust_m))
						}
					else{
						heatmap.2(AC, dendrogram = "both",
						notecol = "black", col = redblue(41), scale = "none", key = TRUE, keysize = 1.1,
						density.info = "none", trace = "none", cexRow = 1.1, cexCol = 1.1,
						breaks = seq(-100, 100, length.out = 42), srtCol = 0, lhei = c(1.2,5),
						key.xlab = "response strength", key.title = "",
						distfun = function(x)dist(x, method = dist_m), hclustfun = function(x)
						hclust(x, method = hclust_m))
						}
					}
					##
					dev.off()
					}
				}
			}
			##
			## heatmap visualization
			{
			if(cell_n == "yes"){
				return(heatmap.2(AC, dendrogram = "both", cellnote = OUT_LP$`table of predictions`,
				notecol = "black", col = redblue(41), scale = "none", key = TRUE, keysize = 1.1,
				density.info = "none", trace = "none", cexRow = 1.1, cexCol = 1.1,
				breaks = seq(-100, 100, length.out = 42), srtCol = 0, lhei = c(1.2,5),
				key.xlab = "response strength", key.title = "",
				distfun = function(x)dist(x, method = dist_m), hclustfun = function(x)
				hclust(x, method = hclust_m)))
				}
			else{
				return(heatmap.2(AC, dendrogram = "both",
				notecol = "black", col = redblue(41), scale = "none", key = TRUE, keysize = 1.1,
				density.info = "none", trace = "none", cexRow = 1.1, cexCol = 1.1,
				breaks = seq(-100, 100, length.out = 42), srtCol = 0, lhei = c(1.2,5),
				key.xlab = "response strength", key.title = "",
				distfun = function(x)dist(x, method = dist_m), hclustfun = function(x)
				hclust(x, method = hclust_m)))
				}
			}
		}
	}
	else{
		cat("\nerror: OUT_LP must be a list generated by the function \"levins_predictions\"")
		cat("\n\n")
		invisible(NULL)
		}
	}
}
