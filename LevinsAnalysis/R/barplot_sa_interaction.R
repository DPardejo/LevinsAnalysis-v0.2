barplot_sa_interaction <- function(OUT_SIS = NA, which_m = "all", n_scenariov = NA,
type_data = "perc", size_lab = 0.8, save_file = "pdf", fname = "community"){
	##
	## error message if the input is not a list object with the following four elements:
	## [1] matches_V
	## [2] matches_pnz_V
	## [3] matches_pn_V
	## [4] link_scenarios
	##
	nomilista <- c("matches_V", "matches_pnz_V",
	"matches_pn_V", "link_scenarios", "tot_nodes")
	{
	if(length(names(OUT_SIS)) == 0) l_ml <- 1
	else l_ml <- length(which(is.na(match(names(OUT_SIS),nomilista))==TRUE))
	}
	##
	{
	if(is.list(OUT_SIS) == TRUE){
		if(l_ml != 0){
			cat("\nerror: OUT_SIS must be a list generated by the function \"sa_interaction\"")
			cat("\n\n")
			invisible(NULL)
		}
		##
		## barplot visualization
		else{
			##
			V_spa <- 0
			##
			n_nodes <- OUT_SIS[[5]]
			s_graph <- n_nodes^2
			##
			## type of scenario considered to identify changes in the sign of predictions
			whichm <- c("all", "pnz", "pn")
			whichm_m <- length(which(is.na(match(which_m, whichm))==FALSE))
			if(whichm_m != 1){
				cat("\nwarning: the user can decide whether to visualize the incidence of scenarios in changes that:\n")
				cat("- involve any type of sign (i.e. \"+\", \"?+\", \"-\", \"?-\", \"0\" or \"0*\"; \"all\")\n")
				cat("- are related to three categories of signs (i.e. \"+\", \"-\" or \"0\"; \"pnz\")\n")
				cat("- classify responses as either positive (\"+\") or negative (\"-\") (i.e. \"pn\")\n")
				cat("which_m was reset to default option (i.e. \"all\")\n\n")
				which_m <- "all"
				V_spa <- 1
			}
			##
			## total number of scenarios that trigger at least one mismatch with reference predictions
			if(which_m == "all"){
				nzpred <- which(OUT_SIS$matches_V != 0)
				{
				if(length(nzpred)!=0)V_bar <- OUT_SIS$matches_V[nzpred]
				else{
					if(V_spa == 1)cat("error: no barplot generated as all elements in matches_V are equal to zero\n\n")
					else cat("\nerror: no barplot generated as all elements in matches_V are equal to zero\n\n")
					return(invisible(NULL))
					}
				}
			}
			if(which_m == "pnz"){
				nzpred <- which(OUT_SIS$matches_pnz_V != 0)
				{
				if(length(nzpred)!=0)V_bar <- OUT_SIS$matches_pnz_V[nzpred]
				else{
					if(V_spa == 1)cat("error: no barplot generated as all elements in matches_pnz_V are equal to zero\n\n")
					else cat("\nerror: no barplot generated as all elements in matches_pnz_V are equal to zero\n\n")
					return(invisible(NULL))
					}
				}
			}
			if(which_m == "pn"){
				nzpred <- which(OUT_SIS$matches_pn_V != 0)
				{
				if(length(nzpred)!=0)V_bar <- OUT_SIS$matches_pn_V[nzpred]
				else{
					if(V_spa == 1)cat("error: no barplot generated as all elements in matches_pn_V are zero\n\n")
					else cat("\nerror: no barplot generated as all elements in matches_pn_V are zero\n\n")
					return(invisible(NULL))
					}
				}
			}
			##
			## number of scenarios to consider for the barplot link
			V_bar_rr <- length(V_bar)
			{
			if(length(n_scenariov) > 1 | is.vector(n_scenariov) == FALSE){
				if(V_spa == 1)cat("warning: the number of scenarios visualized in the barplot must be an integer and strictly positive number\n")
				else cat("\nwarning: the number of scenarios visualized in the barplot must be an integer and strictly positive number\n")
				cat("included between 1 and the number of scenarios (with at least one non-zero value) in the vector of matches\n")
				cat("n_scenariov was reset to default by including all possible scenarios\n\n")
				n_scenariov <- V_bar_rr
				V_spa <- 1
				}
			else{
				if(is.na(n_scenariov) == TRUE){
					n_scenariov <- V_bar_rr
					}
				else{
					if(is.numeric(n_scenariov) == FALSE | n_scenariov < 1 | n_scenariov > V_bar_rr){
						if(V_spa == 1)cat("warning: the number of scenarios visualized in the barplot must be an integer and strictly positive number\n")
						else cat("\nwarning: the number of scenarios visualized in the barplot must be an integer and strictly positive number\n")
						cat("included between 1 and the number of scenarios (with at least one non-zero value) in the vector of matches\n")
						cat("n_scenariov was reset to default by including all possible scenarios\n\n")
						n_scenariov <- V_bar_rr
						V_spa <- 1
						}
					}
				}
			}
			##
			## the barplot can report either percentages or raw values
			type_datan <- c("perc", "raw")
			type_datan_m <- length(which(is.na(match(type_data, type_datan))==FALSE))
			if(type_datan_m != 1){
				if(V_spa == 1)cat("warning: the barplot can visualize either percentages (\"perc\") or raw data (\"raw\")\n")
				else cat("\nwarning: the barplot can visualize either percentages (\"perc\") or raw data (\"raw\")\n")
				cat("type_data was reset to default option (i.e. \"perc\")\n\n")
				type_data <- "perc"
				V_spa <- 1
			}
			##
			## size of the names on the y-axis
			{
			if(length(size_lab) > 1 | is.vector(size_lab) == FALSE){
				if(V_spa == 1)cat("warning: the size of the names on the y-axis must be a strictly positive number\n")
				else cat("\nwarning: the size of the names on the y-axis must be a strictly positive number\n")
				cat("size_lab was reset to default value (i.e. 0.8)\n\n")
				size_lab <- 0.8
				V_spa <- 1
				}
			else{
				if(is.numeric(size_lab) == FALSE){
					if(V_spa == 1)cat("warning: the size of the names on the y-axis must be a strictly positive number\n")
					else cat("\nwarning: the size of the names on the y-axis must be a strictly positive number\n")
					cat("size_lab was reset to default value (i.e. 0.8)\n\n")
					size_lab <- 0.8
					V_spa <- 1
					}
				else if(size_lab <= 0){
					if(V_spa == 1)cat("warning: the size of the names on the y-axis must be a strictly positive number\n")
					else cat("\nwarning: the size of the names on the y-axis must be a strictly positive number\n")
					cat("size_lab was reset to default value (i.e. 0.8)\n\n")
					size_lab <- 0.8
					V_spa <- 1
					}
				}
			}
			##
			##
			{
			if(type_data == "perc"){
				V_bar_s1 <- 100 * V_bar/s_graph
				xx_lab <- "%"
				}
			else{
				V_bar_s1 <- V_bar
				xx_lab <- "count"
				}
			}
			##
			##
			VV <- sort(V_bar_s1, decreasing = TRUE)
			VV_labels <- unlist(lapply(names(VV),function(x)strsplit(x,"_")[[1]][2]))
			limit <- (trunc(max(V_bar_s1)/5) + 1) * 5
			##
			## extension for saving the heatmap
			all_ext <- c("pdf","svg")
			{
			if(length(save_file) > 1 | is.vector(save_file) == FALSE){
				{
				if(V_spa == 1)cat("warning: the format of the image file must be one of the following: \"pdf\" or \"svg\"")
				else cat("\nwarning: the format of the image file must be one of the following: \"pdf\" or \"svg\"")
				}
				cat("\n")
				cat("the format was reset to default (i.e. \"pdf\")")
				cat("\n\n")
				save_file <- "pdf"
				V_spa <- 1
				}
			else{
				s_ext <- which(all_ext == save_file)
				if(length(s_ext) != 1){
					{
					if(V_spa == 1)cat("warning: the format of the image file must be one of the following: \"pdf\" or \"svg\"")
					else cat("\nwarning: the format of the image file must be one of the following: \"pdf\" or \"svg\"")
					}
					cat("\n")
					cat("the format was reset to default (i.e. \"pdf\")")
					cat("\n\n")
					save_file <- "pdf"
					}
				}
			}
			##
			## filename must be a unique element of type character
			{
			if(is.character(fname) == FALSE){
				if(V_spa == 1)cat("warning: the name of the image file must be of type \"character\"\n")
				else cat("\nwarning: the name of the image file must be of type \"character\"\n")
				cat("the name was reset to default option (i.e. \"community\")\n\n")
				fname <- "community"
				V_spa <- 1
				}
			else if(length(fname) > 1){
				if(V_spa == 1)cat("warning: the name of the image file must be a single element of type \"character\"\n")
				else cat("\nwarning: the name of the image file must be a single element of type \"character\"\n")
				cat("the name was reset to default option (i.e. \"community\")\n\n")
				fname <- "community"
				V_spa <- 1
				}
			}
			##
			{
			if(save_file == "svg"){
				file_name1 <- paste(fname, "_barplot_sa_interaction.", save_file, sep = "")
				##
				svg(filename = file_name1)
				##
				ima <- barplot(VV[length(VV):1], xlim = c(0,limit), xlab = xx_lab,
				horiz = TRUE, las = 1, cex.names = size_lab,
				names.arg = VV_labels[length(VV):1])
				##
				dev.off()
				}
			else{
				##
				## produce a pdf file in the working directory
				if(save_file == "pdf"){
					file_name2 <- paste(fname, "_barplot_sa_interaction.", save_file, sep = "")
					##
					pdf(file = file_name2)
					##
					ima <- barplot(VV[length(VV):1], xlim = c(0,limit), xlab = xx_lab,
					horiz = TRUE, las = 1, cex.names = size_lab,
					names.arg = VV_labels[length(VV):1])
					##
					dev.off()
					}
				}
			}
			##
			ima <- barplot(VV[length(VV):1], xlim = c(0,limit), xlab = xx_lab,
			horiz = TRUE, las = 1, cex.names = size_lab,
			names.arg = VV_labels[length(VV):1])
			if(V_spa == 1)cat("correspondence between numbers visualized in the barplot and scenarios:\n\n")
			else cat("\ncorrespondence between numbers visualized in the barplot and scenarios:\n\n")
			correspondence <- data.frame(c(1:length(VV)),OUT_SIS[[4]])
			colnames(correspondence) <- c("scenario_#", colnames(OUT_SIS[[4]]))
			print(correspondence, quote = FALSE, row.names = FALSE)
			invisible(correspondence)
		}
	}
	else{
		cat("\nerror: OUT_SIS must be a list generated by the function \"sa_interaction\"")
		cat("\n\n")
		invisible(NULL)
		}
	}
}
