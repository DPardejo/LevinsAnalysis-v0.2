model_validation <- function(OUT_LP = NA, DF_list = NA, MV_target = NA, fname = "community"){
	##
	## error message if the input is not a list object with the following eight elements:
	## [1] total number of matrices generated
	## [2] total number of stable matrices
	## [3] probability distribution
	## [4] community matrix
	## [5] (%) +
	## [6] (%) -
	## [7] (%) 0
	## [8] table of predictions
	##
	nomilista <- c("total number of matrices generated", "total number of stable matrices",
	"probability distribution", "community matrix", "(%) +", "(%) -", "(%) 0", "table of predictions")
	mistake <- 0
	allowed_signs <- c("+","-","0")
	##
	{
	if(length(names(OUT_LP)) != length(nomilista)) l_ml <- 1
	else l_ml <- length(which(is.na(match(names(OUT_LP),nomilista))==TRUE))
	}
	##
	if(is.matrix(DF_list) == TRUE){
		if(ncol(DF_list) == 2){
			DF_list <- list(DF_list)
		}
	}
	##
	{
	if(is.list(OUT_LP) == TRUE){
		{
		if(l_ml != 0){
			cat("\nerror: OUT_LP must be a list generated by the function \"levins_predictions\"")
			cat("\n\n")
			mistake <- 1
			names_predi <- NA
			n_nodes <- NA
			}
		else{
			names_predi <- colnames(OUT_LP[[8]])
			n_nodes <- length(names_predi)
			}
		}
		##
		{
		if(is.list(DF_list) == FALSE){
			if(mistake == 0){
				cat("\nerror: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
				cat("(1) characters indicating either positive (\"+\") or negative (\"-\") inputs must be in the first column (or element)\n")
				cat("(2) names of the nodes (matching with those of OUT_LP from \"levins_predictions\") must be in the second column (or element)\n")
				cat("DF_list is not a list and does not comply with the required input format")
				cat("\n\n")
				}
			mistake <- 1
			return(invisible(NULL))
			}
		else{
			if(mistake == 0){
				##
				ele_wi <- rep(0,length(DF_list))
				##
				reml <- 0
				remv_1 <- 0
				remv <- 0
				##
				names(DF_list) <- c(1:length(DF_list))
				##
				for(m in 1:length(DF_list)){
					if(is.matrix(DF_list[[m]]) == FALSE & is.vector(DF_list[[m]]) == FALSE){
						DF_list[[m]] <- "wrong"
						ele_wi[m] <- 1
						cat("\nwarning: DF_list must be a list with each element consisting of a two-column matrix (or or two-element vector) where:\n")
						cat("(1) characters indicating either positive (\"+\") or negative (\"-\") inputs must be in the first column (or element)\n")
						cat("(2) names of the nodes (matching with those of OUT_LP from \"levins_predictions\") must be in the second column (or element)\n")
						cat("the following element(s) of DF_list do(es) not comply with the required input format: #", m, sep = "")
						remv_1 <- 1
						remv <- 1
					}
					##
					if(is.matrix(DF_list[[m]]) == FALSE & is.vector(DF_list[[m]]) == TRUE){
						if(length(DF_list[[m]]) != 2){
							DF_list[[m]] <- "wrong"
							ele_wi[m] <- 1
							{
							if(remv_1 == 0){
								{
								if(reml == 1) cat("\n\nwarning: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
								else cat("\nwarning: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
								}
								cat("(1) characters indicating either positive (\"+\") or negative (\"-\") inputs must be in the first column (or element)\n")
								cat("(2) names of the nodes (matching with those of OUT_LP from \"levins_predictions\") must be in the second column (or element)\n")
								cat("the following element(s) of DF_list do(es) not comply with the required input format: #", m, sep = "")
								remv_1 <- 1
								}
							else{
								ele_wi[m] <- 1
								cat(", #", m, sep = "")
								}
							}
						}
					}
					##
					if(is.matrix(DF_list[[m]]) == TRUE & is.vector(DF_list[[m]]) == FALSE){
						if(ncol(DF_list[[m]]) != 2){
							DF_list[[m]] <- "wrong"
							ele_wi[m] <- 1
							{
							if(remv_1 == 0){
								{
								if(reml == 1) cat("\n\nwarning: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
								else cat("\nwarning: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
								}
								cat("(1) characters indicating either positive (\"+\") or negative (\"-\") inputs must be in the first column (or element)\n")
								cat("(2) names of the nodes (matching with those of OUT_LP from \"levins_predictions\") must be in the second column (or element)\n")
								cat("the following element(s) of DF_list do(es) not comply with the required input format: #", m, sep = "")
								remv_1 <- 1
								}
							else{
								ele_wi[m] <- 1
								cat(", #", m, sep = "")
								}
							}
						}
					}
					##
					if(length(DF_list[[m]]) == 2 & is.vector(DF_list[[m]]) == TRUE & is.character(DF_list[[m]]) == TRUE){
						DF_list[[m]] <- matrix(DF_list[[m]], nrow = 1)
					}
					##
					## remove DF_list[[m]] rows if:
					## (1) characters other than "+" and "-" are in the first column
					## (2) names different from node names (or integer numbers larger
					## than network size) are in the second column
					##
					if(length(DF_list[[m]]) > 1){
						if(is.matrix(DF_list[[m]]) == TRUE & is.character(DF_list[[m]]) == TRUE & ncol(DF_list[[m]]) == 2){
							remo1 <- which(is.na(match(DF_list[[m]][,1],c("+","-"))) == TRUE)
							remo2 <- which(is.na(match(DF_list[[m]][,2],names_predi)) == TRUE)
							##
							remo_n1 <- which(is.na(suppressWarnings(as.numeric(DF_list[[m]][,2]))) == FALSE)
							{
							if(length(remo_n1) != 0){
								num_to_nod <- which(is.na(match(c(1:n_nodes),remo_n1)) == FALSE)
								if(length(num_to_nod) != 0){
									num_to_nod_sele <- as.numeric(DF_list[[m]][num_to_nod,2])
									nod_from_num <- names_predi[num_to_nod_sele]
									remo_n2 <- which(is.na(match(c(DF_list[[m]][-num_to_nod,2],nod_from_num),
									names_predi)) == TRUE)
									remo <- unique(c(remo1,remo_n2))
									DF_list[[m]][num_to_nod,2] <- nod_from_num
									}
								}
							else remo <- unique(c(remo1,remo2))
							}
							{
							if(length(remo) == nrow(DF_list[[m]])){
								DF_list[[m]] <- "wrong"
								ele_wi[m] <- 1
								{
								if(remv_1 == 0){
									{
									if(reml == 1) cat("\n\nwarning: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
									else cat("\nwarning: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
									}
									cat("(1) characters indicating either positive (\"+\") or negative (\"-\") inputs must be in the first column (or element)\n")
									cat("(2) names of the nodes (matching with those of OUT_LP from \"levins_predictions\") must be in the second column (or element)\n")
									cat("the following element(s) of DF_list do(es) not comply with the required input format: #", m, sep = "")
									remv_1 <- 1
									}
								else{
									ele_wi[m] <- 1
									cat(", #", m, sep = "")
									}
								}
								}
							else{
								if(length(remo) > 0 & length(remo) < nrow(DF_list[[m]])){
									DF_list[[m]] <- DF_list[[m]][-remo,]
									{
									if(reml == 0){
										{
										if(remv_1 == 1 | reml == 1)cat("\n\nwarning: row(s) removed from the following element(s) of DL_list: #", m, sep = "")
										else cat("\nwarning: row(s) removed from the following element(s) of DL_list: #", m, sep = "")
										}
										reml <- 1
										}
									else{
										cat(", #", m, sep = "")
										}
									}
									}
								}
							}
						}
						else{
							if(remv == 0){
								ele_wi[m] <- 1
								{
								if(reml == 1) cat("\n\nwarning: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
								else cat("\nwarning: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
								}
								cat("(1) characters indicating either positive (\"+\") or negative (\"-\") inputs must be in the first column (or element)\n")
								cat("(2) names of the nodes (matching with those of OUT_LP from \"levins_predictions\") must be in the second column (or element)\n")
								cat("the following element(s) of DF_list do(es) not comply with the required input format: #", m, sep = "")
								remv <- 1
							}
							else{
								ele_wi[m] <- 1
								cat(", #", m, sep = "")
							}
						}
					}
				}
				if(remv == 1 | remv_1 == 1 | reml == 1)cat("\n\n")
				if(remv_1 == 1)reml <- 1
				vspace <- 0
				from_vtm <- 0
				##
				{
				if(sum(ele_wi) < length(DF_list)){
					if(is.vector(MV_target) == TRUE){
						nomi_target <- names(MV_target)
						nomi_match <- match(names_predi, nomi_target)
						nomi_target_ele <- which(is.na(nomi_match)==TRUE)
						nomi_target_l <- length(nomi_target_ele)
						if(nomi_target_l != 0 & vspace == 0){
							if(reml == 0)cat("\nerror: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
							else cat("error: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
							cat("(1) names (or column names) must match those of the community matrix\n")
							cat("(2) the number of rows in the matrix must match the number of elements in DF_list\n")
							cat("(3) the signs (i.e. MV_target elements) allowed are \"+\", \"-\", \"0\" or NA")
							cat("\n\n")
							vspace <- 1
						}
						if(length(DF_list) > 1 & vspace == 0){
							if(reml == 0)cat("\nerror: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
							else cat("error: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
							cat("(1) names (or column names) must match those of the community matrix\n")
							cat("(2) the number of rows in the matrix must match the number of elements in DF_list\n")
							cat("(3) the signs (i.e. MV_target elements) allowed are \"+\", \"-\", \"0\" or NA")
							cat("\n\n")
							vspace <- 1
						}
						if((length(which(is.na(match(MV_target,allowed_signs))==TRUE)) -
						length(which(is.na(MV_target)==TRUE)))!=0 & vspace == 0){
							if(reml == 0)cat("\nerror: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
							else cat("error: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
							cat("(1) names (or column names) must match those of the community matrix\n")
							cat("(2) the number of rows in the matrix must match the number of elements in DF_list\n")
							cat("(3) the signs (i.e. MV_target elements) allowed are \"+\", \"-\", \"0\" or NA")
							cat("\n\n")
							vspace <- 1
						}
						##
						{
						if(vspace == 1)MV_target <- NA
						else{
							MV_target_mat <- MV_target
							MV_target <- matrix(MV_target_mat, nrow = 1)
							colnames(MV_target) <- nomi_target
							rownames(MV_target) <- c(1:nrow(MV_target))
							from_vtm <- 1
							}
						}
					}
					##
					if(is.matrix(MV_target) == TRUE){
						nomi_target <- colnames(MV_target)
						rownames(MV_target) <- c(1:nrow(MV_target))
						nomi_match <- match(names_predi, nomi_target)
						nomi_target_ele <- which(is.na(nomi_match)==TRUE)
						nomi_target_l <- length(nomi_target_ele)
						if(nomi_target_l != 0){
							if(from_vtm == 0 & vspace == 0){
								cat("\nerror: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
								cat("(1) names (or column names) must match those of the community matrix\n")
								cat("(2) the number of rows in the matrix must match the number of elements in DF_list\n")
								cat("(3) the signs (i.e. MV_target elements) allowed are \"+\", \"-\", \"0\" or NA")
								cat("\n\n")
								vspace <- 1
							}
						}
						if(nrow(MV_target) != length(DF_list)){
							if(from_vtm == 0 & vspace == 0){
								if(reml == 0)cat("\nerror: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
								else cat("error: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
								cat("(1) names (or column names) must match those of the community matrix\n")
								cat("(2) the number of rows in the matrix must match the number of elements in DF_list\n")
								cat("(3) the signs (i.e. MV_target elements) allowed are \"+\", \"-\", \"0\" or NA")
								cat("\n\n")
								vspace <- 1
							}
						}
						sign_deviation <- matrix(rep(1,length(MV_target)), nrow = nrow(MV_target))
						colnames(sign_deviation) <- colnames(MV_target)
						sign_deviation_NA <- sign_deviation
						for(p in 1:nrow(MV_target)){
							for(n in 1:ncol(MV_target)){
								if(is.na(match(MV_target[p,n],allowed_signs)) == FALSE)sign_deviation[p,n] <- 0
								##
								if(is.na(MV_target[p,n]) == FALSE)sign_deviation_NA[p,n] <- 0
							}
						}
						sign_deviation_diff <- sign_deviation - sign_deviation_NA
						sign_deviation_s1 <- which(apply(sign_deviation_diff,1,sum) != 0)
						eff_p <- which(apply(sign_deviation_diff,1,sum) == 0)
						sign_deviation_s2 <- length(sign_deviation_s1)
						if(sign_deviation_s2 != 0){
							if(sign_deviation_s2 == nrow(MV_target)){
								if(from_vtm == 0 & vspace == 0){
									if(reml == 0)cat("\nerror: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
									else cat("error: MV_target must be either a vector or a matrix of type \"character\" with the following properties:\n")
									cat("(1) names (or column names) must match those of the community matrix\n")
									cat("(2) the number of rows in the matrix must match the number of elements in DF_list\n")
									cat("(3) the signs (i.e. MV_target elements) allowed are \"+\", \"-\", \"0\" or NA")
									cat("\n\n")
									vspace <- 1
								}
							}
							else{
								if(reml == 0)cat("\nwarning: signs allowed in MV_target are: \"+\", \"-\", \"0\" or NA\n")
								else cat("warning: signs allowed in MV_target are: \"+\", \"-\", \"0\" or NA\n")
								cat("the following rows were removed from MV_target as they did not comply with such requirement: #")
								for(p in 1:length(sign_deviation_s1)){
									if(p == 1)cat(sign_deviation_s1[p])
									else cat(", #", sign_deviation_s1[p], sep = "")
								}
								cat("\n")
								cat("also the corresponding element(s) of DF_list was (were) removed")
								cat("\n\n")
								MV_target1 <- MV_target
								newnames <- rownames(MV_target)
								MV_target <- MV_target1[-sign_deviation_s1,]
								newnames <- newnames[-sign_deviation_s1]
								if(is.vector(MV_target)==TRUE){
									MV_target <- matrix(MV_target, nrow = 1)
									colnames(MV_target) <- colnames(MV_target1)
									rownames(MV_target) <- newnames
								}
								DF_list1 <- DF_list
								DF_list <- list.remove(DF_list, range = sign_deviation_s1)
								ele_wi <- ele_wi[-sign_deviation_s1]
							}
						}
					}
				ll_list <- length(DF_list)
				matches_pe <- matrix(rep(0,(ll_list * 2)), nrow = ll_list)
				}
				else{
					if(remv == 0 & remv_1 == 0){
						cat("\nerror: DF_list must be a list with each element consisting of a two-column matrix (or two-element vector) where:\n")
						cat("(1) characters indicating either positive (\"+\") or negative (\"-\") inputs must be in the first column (or element)\n")
						cat("(2) names of the nodes (matching with those of OUT_LP from \"levins_predictions\") must be in the second column (or element)\n")
						cat("none of the DF_list elements complies with the required input format")
						cat("\n\n")
						return(invisible(NULL))
						}
					}
				}
				##
				if(sum(ele_wi) < length(DF_list) & vspace == 0){
					##
					count_rounds <- 1
					for(p in 1:length(DF_list)){
						melt <- c(DF_list[[p]])[1]
						{
						if(melt != "wrong"){
							cat("\n", count_rounds, " - predictions for the input(s) in the element #", eff_p[p], " of DF_list", sep = "")
							cat("\n")
							count_rounds <- count_rounds + 1
							ris_s1 <- levins_concurrent_ns(OUT_LP, DF = DF_list[[p]], fname = NA)
							{
							if(length(ris_s1) != 0){
								ris_s1_sign <- ris_s1[nrow(ris_s1),]
								##
								ris_s1_sign_p <- which(ris_s1_sign == "?+")
								ris_s1_sign_n <- which(ris_s1_sign == "?-")
								ris_s1_sign_z <- which(ris_s1_sign == "0*")
								##
								if(length(ris_s1_sign_p) != 0)ris_s1_sign[ris_s1_sign_p] <- "+"
								##
								if(length(ris_s1_sign_n) != 0)ris_s1_sign[ris_s1_sign_n] <- "-"
								##
								if(length(ris_s1_sign_z) != 0)ris_s1_sign[ris_s1_sign_z] <- "0"
								##					
								counting <- 0
								ris_s1_sign_sel <- ris_s1_sign[names_predi[which(is.na(nomi_match)==FALSE)]]
								con_s1_sign_sel <- MV_target[p,nomi_target[nomi_match[which(is.na(nomi_match)==FALSE)]]]
								for(v in 1:length(ris_s1_sign_sel)){
									if(is.na(con_s1_sign_sel[v]) == FALSE)
										if(ris_s1_sign_sel[v] == con_s1_sign_sel[v])counting <- counting + 1
								}
								matches_pe[p,1] <- counting
								matches_pe[p,2] <- length(which(is.na(con_s1_sign_sel)==FALSE))
								cat("number of correct predictions = ", matches_pe[p,1],
								" (out of ", matches_pe[p,2], ")", sep = "")
								cat("\n\n")
								}
								else{
									cat("warning: none of the simulated matrices was stable\n")
									cat("there are no correct matches out of total expected predictions")
									cat("\n\n")
									matches_pe[p,1] <- NA
									con_s1_sign_sel <- MV_target[p,nomi_target[nomi_match[which(is.na(nomi_match)==FALSE)]]]
									matches_pe[p,2] <- length(which(is.na(con_s1_sign_sel)==FALSE))
								}
							}
						}
						else{
							con_s1_sign_sel <- MV_target[p,nomi_target[nomi_match[which(is.na(nomi_match)==FALSE)]]]
							matches_pe[p,1] <- NA
							matches_pe[p,2] <- length(which(is.na(con_s1_sign_sel)==FALSE))
							}
						}
					}
				removal_NArows <- which(is.na(matches_pe[,1])==TRUE)
				if(length(removal_NArows)!=0)matches_pe <- matches_pe[-removal_NArows,]
				if(is.vector(matches_pe) == TRUE)matches_pe <- matrix(matches_pe, nrow = 1)
				colnames(matches_pe) <- c("correct", "total")
				{
				if(length(removal_NArows)!=0){
					r_names_mpe <- paste0("DF_list_", eff_p)
					rownames(matches_pe) <- r_names_mpe[-removal_NArows]
					}
				else rownames(matches_pe) <- paste0("DF_list_", eff_p)
				}
				##
				{
				if(length(matches_pe) != 0){
					if(length(fname) == 1){
						if(is.character(fname) == TRUE){
							file_name_txt <- paste(fname, "_model_validation.txt", sep = "")
							}
						else{
							fname <- "community"
							file_name_txt <- paste(fname, "_model_validation.txt", sep = "")
							cat("warning: fname must be a single element of type \"character\"\n")
							cat("fname was reset to default (i.e. \"community\")", sep = "")
							cat("\n\n")
							}
					}
					else{
						fname <- "community"
						file_name_txt <- paste(fname, "_model_validation.txt", sep = "")
						cat("warning: fname must be a single element of type \"character\"\n")
						cat("fname was reset to default (i.e. \"community\")", sep = "")
						cat("\n\n")
					}
				}
				##
				if(length(matches_pe) != 0){
					nn_r <- nrow(matches_pe)
					nn_n <- rownames(matches_pe)
					nn_r_LISTA <- as.list(rep(NA,nn_r))
					numbero_lett_V <- rep(NA,nn_r)
					sink(file_name_txt)
					for(x in 1:nn_r){
						numbero <- as.integer(strsplit(nn_n[x], "DF_list_")[[1]][2])
						numbero_lett <- as.character(numbero)
						{
						if(x == 1)cat(x, " - predictions for the input(s) in the element #", numbero, " of DF_list\n", sep = "")
						else cat("\n", x, " - predictions for the input(s) in the element #", numbero, " of DF_list\n", sep = "")
						}
						levins_concurrent_ns(OUT_LP, DF = DF_list[[numbero_lett]], fname = NA)
						nn_r_LISTA[[x]] <- DF_list[[numbero_lett]]
						numbero_lett_V[x] <- numbero_lett
					}
					sink()
					cat(paste("results are in the file \"", file_name_txt, "\"", sep = ""))
					cat("\n\n")
					}
				else{
					cat("\nwarning: there are no results to save in the file \"", file_name_txt, "\"", sep = "")
					}
				}
				##
				if(is.vector(MV_target)==FALSE){
					sleli <- which(is.na(match(rownames(MV_target), numbero_lett_V))==FALSE)
					MV_target <- MV_target[sleli,]
				}
				nn_r_LISTA[[(length(nn_r_LISTA)+1)]] <- MV_target
				nn_r_LISTA[[(length(nn_r_LISTA)+1)]] <- matches_pe
				names(nn_r_LISTA) <- c(rownames(matches_pe), "target", "validation")
				return(invisible(nn_r_LISTA))
				}
				##
				}
			}
		}
	}
	else{
		cat("\nerror: OUT_LP must be a list generated by the function \"levins_predictions\"")
		cat("\n\n")
		return(invisible(NULL))
		}
	}
}
